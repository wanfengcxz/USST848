[TOC]



### Prim

```c++
struct CloseEdge{
    VerTexType adjvex;
    ArcType lowcost;
}
CloseEdge closeedge[MVNum];

void MiniSpanTree_Prim(AMGraph G, VerTexType vex){
	k = locateVex(G, vex);
    for (int i=0;i<G.vexnum;i++)
        if (i != k) closeedge[i] = {vex, G.arcs[k][i]};
    closeedge[k].lowcost=0;
    for (int i=1;i<G.vexnum;i++){
        k=Min(closeedge);
        v0=closeedge[k].adjvex;
        v1=G.vexs[k];
        cout << v0 << v1 << endl;
        closeedge[k].lowcost=0;
        for (int j=0;j<G.vexnum;j++){
            if (closeedge[j].lowcost>G.arcs[k][j])
        		closeedge[j]={G.vexs[k],G.arcs[k][j]};
        }	
    }
}
```

### Kruskal

```c++
struct Edge{
	VerTexType s; // start
    VerTexType e; // end
    ArcType lowcost;
}

Edge edges[arcnum];
int vexset[MVNum];

void MiniSpanTree_kruskal(AMGraph G){
    sort(edges); // min to max
    for (int i=0;i<G.vexnum;i++)
        vexset[i]=i;
    for(int i=0;i<G.arcnum;i++){
        v0=LocateVex(G, edges[i].s);
        v1=LocateVex(G, edges[i].e);
        v0s=vexset[v0];
        v1s=vexset[v1];
        if (v1s!=v0s){
            cout<<edges[i].s<<edges[i].e<<endl;
            for(int j=0;j<vexnum;++j)
                if (vexset[j]==v1s)
                    vexset[j]=v0s;
        }
    }
}
```

### Floyd

```c++
void ShortestPath_Floyd(AMGraph G){
    // 初始化路径信息
    for (int i=0;i<G.vexnum;++i){
        for (int j=0;j<G.vexnum;++j){
            D[i][j]=G.arcs[i][j];
            if (D[i][j]!=MaxInt) Path[i][j]=i; // 有弧 前驱置为i
            else Path[i][j]=-1;				  // 没有弧 前驱置为-1
        }
    }
    
    for (int k=0;k<G.vexnum;++k){
        for (int i=0;i<G.vexnum;++i){
            for (int j=0;j<G.vexnum;++j){
                if (D[i][k]+D[k][j] < D[i][j]){ // i经k到j有更短的路径
                    D[i][j]=D[i][k]+D[k][j];
                    Path[i][j]=Path[k][j];
                }
            }
        }
    }
}
```

### TopologicalSort

```c++
Status TopologicalSort(AMGraph G, int topo[]){
    FindInDegree(G, indegree); // 求出各顶点的入度存入数组
    InitStack(S); // 初始化栈
    for(int i=0;i<G.vexnum;++i) // 入度为0进栈
        if (indegree[i]==0) Push(S, i);
    m=0;
    while(!StackEmpty(S)){
        Pop(S, i); 
        topo[m]=i;
        ++m;		// 出栈保存当前序号
        p=G.vertices[i].firstarc; // p指向vi的第一个邻接点
        while(p!=NULL){
            k=p->adjvex;
            --indegree[k];		// 入度减一
            if (indegree[k]==0) Push(S, k); // 度数为0的节点进栈
            p=p->nextarc;
        }
    }
    if (m<G.vexnum) return ERROR;
    else return OK;
}
```

### 

### 堆排序

```c++
void maxHeapify(int arr[], int s, int e){
	int dad=s;
    int son=dad*2+1;
    while(son<=e){
        if (son+1<=e&&arr[son]<arr[son+1])
            ++son;
        if (arr[dad]>arr[son])
            return ;
        else{
            swap(arr[dad],arr[son]);
            dad=son;
            son=dad*2+1;
        }
    }
}

void heapSort(int arr[], int len){
    for(int i=len/2-1;i>=0;i--)
        maxHeapify(arr, i, len-1);
    for(int i=len-1;i>0;i--){
        swap(arr[0], arr[i]);
        maxHeapify(arr,0,i-1);
    }
}
```

### 快速排序

```c++
void QuickSort(int arr[], int len){
	int privot=arr[0];
}
```

### 

```c++
阿斯弗
```



### 二分查找

```c++
// little to big
int binarySearch(int arr[], int s, int e, int target){
    int mid=0;
    // 注意如果跳出循环 则s指向最小的大于target的数
    while(s<=e){
        mid=s+(e-s)/2;
        if (arr[mid]==target)
            return mid;
        else if (arr[mid]>target)
            e=mid-1;
        else
            s=mid+1;
    }
    return -1;
}
```

### huffmanTree





```c++

```

### 

```c++

```

# 矩阵

### 矩阵旋转90

```c++
// nxn
const int n=4;
void Transpose(int arr[n][n]){
    int tmp;
    // 转置
    for(int i=0;i<n;++i)
        // 此处为i即可
        for(int j=0;j<i;++j){
            tmp = arrp[i][j];
            arr[i][j]=arr[j][i];
            arr[j][i]=tmp;
        }
            
    // 水平镜像
    for (int i=0;i<n;++i)
        for (int j=0;j<n/2;j++){
            tmp=arr[i][j];
            arr[i][j]=arr[i][n-1-j];
            arr[i][n-1-j]=tmp;
        }
}
```

###  矩阵翻转180

```c++
const int n=4;
void Rotation(int arr[n][n]){
	int tmp;
    // 水平镜像
    for (int i=0;i<n;++i)
        for(int j=0;j<n/2;++j){
            tmp=arr[i][j];
            arr[i][j]=arr[i][n-j-1];
            arr[i][n-j-1]=tmp;
        }
    // 垂直镜像
    for (int i=0;i<n/2;++i)
        for (int j=0;j<n;++j){
            tmp=arr[i][j];
            arr[i][j]=arr[n-i-1][j];
            arr[n-i-1][j]=arr[i][j];
        }
}
```

### 矩阵水平镜像（见矩阵旋转90

### 矩阵转置（见矩阵旋转90

### 矩阵垂直镜像（见矩阵旋转180

# 链表

### 反转链表

```c++
// 假设有头结点
void reverse(ListNode *head){
    if (head->next==nullptr)
        return ;
    ListNode *pre=head->next,*work=head->next->next, *cur=nullptr;
   	while(work!=nullptr){
        pre->next=cur;
        cur=pre;
        pre=work;
        work=work->next;
    }
    pre->next=cur;
    head->next=pre;
}
```

### 相交链表

```c++
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB){
    if (headA==nullptr||headB==nullptr)
        return nullptr;
    ListNode *A=headA, *B=headB;
    while(A!=B){
        A->next==nullptr?A=headB:A=A->next;
        B->next==nullptr?B=headA:B=B->next;
    }
    return A;
}
```

### 删除链表倒数第N个节点 ⭐

```c++
// 双指针
ListNode *removeNthFromEnd(ListNode *head, int n){
    // 构造一个临时头结点对付特殊情况——删除头结点
    ListNode firt;
    first.next=head;
    ListNode *front=&first, *rear=&first;
    int i=0;
    while(i<n){
        rear=rear->next;
        ++i; // !!!!!!!
    }
    while(rear->next){
        front=front->next;
        rear=rear->next;
    }
    rear=front->next;
    front->next=front->next->next;
    delete rear;
    return first.next;
}
```

### 链表中第K个节点

```c++
// 双指针
ListNode *getKthFormEnd(ListNode *head, int k){
    ListNode *front=head, *rear=head;
    while(k>0){
		rear=rear->next;
        k--;
    }
    while(rear){
        rear=rear->next;
        front=front->next;
    }
    return front;
}
```

### 

```c++

```



# 栈和队列

### 两个栈实现一个队列

```c++
class MyQueue{
    stack<T> in; // 入队栈
    stack<T> out; // 出队栈
public:    
    void enQueue(T v){
		in.push(v);
    }
    
    bool empty(){
    	return in.empty()&&out.empty();
    }
    
    T deQueue(){
        if (this->empty())
            Error;
        if (out.empty()){
            while (!in.empty()){
                out.push(in.top());
                in.pop();
            }
        }
        T tmp=out.top();
        out.pop();
        return tmp;
    }
    
}
```

### 包含min函数的栈

```c++
class MinStack{
    Stack<T> s;
    Stack<T> min;
public:
    void push(T v){
        s.push(v);
        if (min.empty())
            min.push(v);
        else{
            if (min.top()>v)
                min.push(v);
        }
    }
    
    T min(){
        return min.top();
    }
    
    void pop(){
        if (s.empty())
            return;
        if (s.top()==min.top()){
            s.pop();
            min.pop();
        }
        else{
            s.pop();
        }
    }
}
```

# 线性表

### 删除数组中的最小元素

```c++
bool deleteMinElem(SqList &L, ElemType &v){
    if (L.length==0)
        return false;
    int min=0;
    // 找到最小元素
    for(int i=1;i<L.length;i++)
        if (L.data[i]<L.data[min])
            min=i;
    v=L.data[min];
    // 从min开始逐个前移一位
    for(int i=min+1;i<length;i++)
        L.data[i-1]=L.data[i];
    /* 或者直接把表尾元素复制过来
   		L.data[min]=L.data[L.lenght-1];
    */
    L.lenght--; // 非常重要！！！！
    return true;
}
```

### 反转线性表

```c++
void ReverseSqList(SqList &L){
    ElemType tmp;
    for(int i=0;i<L.length/2;i++){
        tmp=L.data[i];
        L.data[i]=L.data[L.length-1-i];
        L.data[L.length-1-i]=tmp;
    }
}
```

### 移除线性表中等于x的元素 ⭐

```c++
void delete1Elem(SqList &L, ElemType x){
    int k=0;
    for(int i=0;i<L.length;++i)
        L.data[i]==x?x++:L.data[i-k]=L.data[i];
    L.length-=k; // 不能忘！！！
}
```

### 删除有序线性表大于s小于t的元素 ⭐

```c++
bool deleteElemS2T(SqList &L, ElemType s, ElemType t){
    if (s>=t||L.length==0)
        return false;
    int count=0;
    int i=0;
    // 统计介于s到t之间的元素
    for(;i<L.length;)
        if (L.data[i]>s&&L.data[i]<t)
            count++;
    	else if (L.data[i]>t)
            break;
    if (count==0)	// 没有找到
        return false;
    for(;i<L.length;++i)
        L.data[i-count]=L.data[i];
    L.length-=count; // !!!!!!!!!!
    return true;
}
```

```c++
// 第二版 更精简
void deleteElemS2T(SqList &L, ElemType s, ElemType t){
    int count=0;
   	for(int i=0;i<L.length;++i)
        L.data[i]>s&&L.data[i]<t?++count:L.data[i-count]=L.data[i];
    L.lenght-=count;
}
```

### 删除递增有序表的相同元素 ⭐

```c++
void deleteElem(SqList &L){
    if (L.length==0)
        return ;
    int i=0, j=1;
    while (j<L.length){
        if (L.data[i]!=L.data[j]){
            L.data[i+1]=L.data[j];
            ++i;++j;
        }
        else
            ++j;
    }
    L.length=i+1;
}
// 如果考试无思路或者是无需表 可以使用哈希表来判断是否重复
```

### 将两个有序表合并为一个有序表

```c++
bool mergeSqList(SqList L1, SqList L2, SqList &L3){
    if (L1.length+L2.length>MaxSize) // !!!!!!!
        return false;
    int i=0, j=0, k=0;
    while(i<L1.length&&j<L2.length)
        L1.data[i]>L2.data[j]?L3.data[k++]=L2.data[j++]:L3.data[k++]=L1.data[i++];
    while(i<L1.length)
        L3.data[k++]=L1.data[i++];
    while(j<L2.length)
        L3.data[k++]=L1.data[j++];
    L3.length=k;
    return true;
}
```

### 寻找有序表中x的位置，如果不存在则插入元素x，且仍然保持线性表有序i

```c++

```

### 循环左移

```c++
bool cycleShiftLeft(ElemType arr[], int len, int num){
    if(num<=0)
        return false;
    numm=num%len;
    reverse(arr, 0, num-1);
    reverse(arr, num, len-1);
    reverse(arr, 0, len-1);
	return true;
}

bool reverse(ElemType arr[], int s, int e){
    if (s>=e)
        return false;
    ElemType tmp;
    while(s<e){
        tmp=arr[s];
        arr[s++]=arr[e];
        arr[e--]=tmp;
    }
}
```

### 数组中重复的数字

```c++
int findRepeatNumber(vector<int> &arr){
    unordered_set<int> hashset;
    for(auto v:arr)
        if (hashset.count(v)>0)
            return v;
    	else
            hashset.insert(v);
    return -1;
}
```

### 

```c++

```



# 字符串

### 只出现一次的字符

```c++
char findUniqueCh(string s){
    unordered_map<char, bool> hashmap;
    for (auto ch:s)
        if (hashmap.count(ch)<=0)
            hashmap[ch]=true;
    	else
            hashmap[ch]=false;
    for(int i=0;i<s.size();++i)
        if (hashmap[s[i]])
            return s[i];
    return ' ';
}
```

### 

```c++

```

### 

```c++

```



# 二叉树

### 平衡二叉树

```c++

```

### 镜像二叉树 ⭐

```c++
// 返回当前二叉树的镜像
TreeNode *mirrorTree(TreeNode *root){
    if (root==nullptr)
        return nullptr;
    TreeNode *tmp=root->left;
    root->left=mirrorTree(root->right);
    root->right=mirrorTree(tmp);
    return root;
}
```

### 

```c++
 
```

### 

```c++

```



# 哈希表

### C++STL中的哈希集合

```c++
#include <unordered_set>
using namespace std;

unordered_set<T> hashset;
// 常用操作
// 插入
hashset.insert(v);
// 删除
hashset.erase(v);
// 判断某元素是否存在 出现的次数
hashset.count(v)==0
// 遍历
for (auto p=hashset.begin();p!=hashset.end();++p)
    cout << *p << endl;
```

### HashSet

```c++
class MyHashSet{
public:
    vector<T> backets[10000];
    MyHashSet(){}
    int getIndex(T key){
        return H(key); // key%10000;
    }
    
    void add(T key){
        int index=getIndex(key);
        if (!contain(key))
            backets[index].push_back(key);
    }
    
    void remove(T key){
        int index=getIndex(key);
        if (backets[index].size()==0)
            return ;
        for(int i=0;i<backets[index].size();++i)
            if (backets[index][i]==key)
                backets[index].earse(backets[index].begin()+i);
    }
    
    bool contain(T key){
        int index=getIndex(key);
        if (backets[index].size()==0)
            return false;
        else{
            for(auto v:backets[index])
                if (v==key)
                    return true;
        }
        return false;
    }

};
```

### HashMap

### 

```c++
阿斯弗
```

### 

```c++

```

