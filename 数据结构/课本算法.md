[TOC]



### Prim

```c++
struct CloseEdge{
    VerTexType adjvex;
    ArcType lowcost;
}
CloseEdge closeedge[MVNum];

void MiniSpanTree_Prim(AMGraph G, VerTexType vex){
	k = locateVex(G, vex);
    for (int i=0;i<G.vexnum;i++)
        if (i != k) closeedge[i] = {vex, G.arcs[k][i]};
    closeedge[k].lowcost=0;
    for (int i=1;i<G.vexnum;i++){
        k=Min(closeedge);
        v0=closeedge[k].adjvex;
        v1=G.vexs[k];
        cout << v0 << v1 << endl;
        closeedge[k].lowcost=0;
        for (int j=0;j<G.vexnum;j++){
            if (closeedge[j].lowcost>G.arcs[k][j])
        		closeedge[j]={G.vexs[k],G.arcs[k][j]};
        }	
    }
}
```

### Kruskal

```c++
struct Edge{
	VerTexType s; // start
    VerTexType e; // end
    ArcType lowcost;
}

Edge edges[arcnum];
int vexset[MVNum];

void MiniSpanTree_kruskal(AMGraph G){
    sort(edges); // min to max
    for (int i=0;i<G.vexnum;i++)
        vexset[i]=i;
    for(int i=0;i<G.arcnum;i++){
        v0=LocateVex(G, edges[i].s);
        v1=LocateVex(G, edges[i].e);
        v0s=vexset[v0];
        v1s=vexset[v1];
        if (v1s!=v0s){
            cout<<edges[i].s<<edges[i].e<<endl;
            for(int j=0;j<vexnum;++j)
                if (vexset[j]==v1s)
                    vexset[j]=v0s;
        }
    }
}
```

### Floyd

```c++
void ShortestPath_Floyd(AMGraph G){
    // 初始化路径信息
    for (int i=0;i<G.vexnum;++i){
        for (int j=0;j<G.vexnum;++j){
            D[i][j]=G.arcs[i][j];
            if (D[i][j]!=MaxInt) Path[i][j]=i; // 有弧 前驱置为i
            else Path[i][j]=-1;				  // 没有弧 前驱置为-1
        }
    }
    
    for (int k=0;k<G.vexnum;++k){
        for (int i=0;i<G.vexnum;++i){
            for (int j=0;j<G.vexnum;++j){
                if (D[i][k]+D[k][j] < D[i][j]){ // i经k到j有更短的路径
                    D[i][j]=D[i][k]+D[k][j];
                    Path[i][j]=Path[k][j];
                }
            }
        }
    }
}
```

### TopologicalSort

```c++
Status TopologicalSort(AMGraph G, int topo[]){
    FindInDegree(G, indegree); // 求出各顶点的入度存入数组
    InitStack(S); // 初始化栈
    for(int i=0;i<G.vexnum;++i) // 入度为0进栈
        if (indegree[i]==0) Push(S, i);
    m=0;
    while(!StackEmpty(S)){
        Pop(S, i); 
        topo[m]=i;
        ++m;		// 出栈保存当前序号
        p=G.vertices[i].firstarc; // p指向vi的第一个邻接点
        while(p!=NULL){
            k=p->adjvex;
            --indegree[k];		// 入度减一
            if (indegree[k]==0) Push(S, k); // 度数为0的节点进栈
            p=p->nextarc;
        }
    }
    if (m<G.vexnum) return ERROR;
    else return OK;
}
```

### HashSet

```c++
class MyHashSet{
public:
    vector<T> backets[10000];
    MyHashSet(){}
    int getIndex(T key){
        return H(key); // key%10000;
    }
    
    void add(T key){
        int index=getIndex(key);
        if (!contain(key))
            backets[index].push_back(key);
    }
    
    void remove(T key){
        int index=getIndex(key);
        if (backets[index].size()==0)
            return ;
        for(int i=0;i<backets[index].size();++i)
            if (backets[index][i]==key)
                backets[index].earse(backets[index].begin()+i);
    }
    
    bool contain(T key){
        int index=getIndex(key);
        if (backets[index].size()==0)
            return false;
        else{
            for(auto v:backets[index])
                if (v==key)
                    return true;
        }
        return false;
    }

};
```

### HashMap







### huffmanTree





```c++
struct Edge{
    VerTexType s;
    VerTexType e;
    ArcType cost;
}

void SpanMiniTree_Kruskal(AMGraph G){
    Init(edges);
    sort(edges);
    for(int i=0;i<vexnum;++i)
        vexset[i]=i;
    for(int i=0;i<G.arcnum;++i){
        v0=LocateVex(G, edges[i].s);
        v1=LocateVex(G, edges[i].e);
        v0s=vexset[v0];
        v1s=vexset[v1];
        if (v1s!=v0s){
            cout << G.vexs[v0] << G.vexs[v1] << endl;
            for(int j=0;j<G.vexnum;++j)
                if (vexset[j]==v1s)
                    vexset[j]=v0s;
        }
        
    }
}

void ShortestPath_Floyd(AMGraph G){
    for(int i=0;i<G.vexnum;++i){
        for(int j=0;j<G.vexnum;++j){
            D[i][j]=G.arcs[i][j];
            if (D[i][j]!=MaxInt) Path[i][j]=i;
            else Path[i][j]=-1;
        }
    }
	
    for(int k=0;k<G.vexnum;++k){
        for(int i=0;i<G.vexnum;++i){
            for(int j=0;j<G.vexnum;++j){
                if (D[i][k]+D[k][j]>D[i][j]){
                    D[i][j]=D[i][k]+D[k][j];
                    Path[i][j]=Path[k][j];
                }
            }
        }
    }
}

bool topologicalSort(AMGraph G, int topo[]){
 	FindInDegree(G, indegree);
    InitStack(S);
    for(int i=0;i<G.vexnum;++i)
        if(indegree[i]==0) Push(S, i);
    m=0;
    while(!StackEmpty(S)){
        Pop(S,i);
        topo[m]=i;
        ++m;
        p=G.vextices[i].firstarc;
        while(p!=NULL){
            k=p->adjvex;
            --indegree[k];
            if (indegree[k]==0)
                Push(S, k);
            p=p->nextarc;
        }
    }
    if (m < G.vexnum) return false;
    else return true;
}


bool topologicalSort(AMGraph G, int topo[]){
    FindInDegree(G, indegrees);
    InitStack(S);
    for(int i=0;i<G.vexnum;++i)
        if (indegrees[i]==0)
            Push(S, i);
    m=0;
    while(!StackEmpty(S)){
        Pop(S, i);
        topo[m]=i;
        ++m;
        p=G.vertices[i].firstarc;
        while(p!=NULL){
            k=p->adjvex;
            --indegrees[k];
            if (indegrees[k]==0) Push(S, k);
            p=p->nextarc;
        }
    }
    if (m<G.vexnum) return false;
    else return true;
}



```

### 

```c++

```

### 矩阵旋转90

```c++
// nxn
const int n=4;
void Transpose(int arr[n][n]){
    int tmp;
    // 转置
    for(int i=0;i<n;++i)
        // 此处为i即可
        for(int j=0;j<i;++j){
            tmp = arrp[i][j];
            arr[i][j]=arr[j][i];
            arr[j][i]=tmp;
        }
            
    // 水平镜像
    for (int i=0;i<n;++i)
        for (int j=0;j<n/2;j++){
            tmp=arr[i][j];
            arr[i][j]=arr[i][n-1-j];
            arr[i][n-1-j]=tmp;
        }
}
```

###  矩阵翻转180

```c++
const int n=4;
void Rotation(int arr[n][n]){
	int tmp;
    // 水平镜像
    for (int i=0;i<n;++i)
        for(int j=0;j<n/2;++j){
            tmp=arr[i][j];
            arr[i][j]=arr[i][n-j-1];
            arr[i][n-j-1]=tmp;
        }
    // 垂直镜像
    for (int i=0;i<n/2;++i)
        for (int j=0;j<n;++j){
            tmp=arr[i][j];
            arr[i][j]=arr[n-i-1][j];
            arr[n-i-1][j]=arr[i][j];
        }
}
```

### 矩阵水平镜像（见矩阵旋转90

### 矩阵转置（见矩阵旋转90

### 矩阵垂直镜像（见矩阵旋转180

### 两个栈实现一个队列

```c++
class MyQueue{
    stack<T> in; // 入队栈
    stack<T> out; // 出队栈
public:    
    void enQueue(T v){
		in.push(v);
    }
    
    bool empty(){
    	return in.empty()&&out.empty();
    }
    
    T deQueue(){
        if (this->empty())
            Error;
        if (out.empty()){
            while (!in.empty()){
                out.push(in.top());
                in.pop();
            }
        }
        T tmp=out.top();
        out.pop();
        return tmp;
    }
    
}
```

#### 反转链表

```c++
// 假设有头结点
void reverse(ListNode *head){
    if (head->next==nullptr)
        return ;
    ListNode *pre=head->next,*work=head->next->next, *cur=nullptr;
   	while(work!=nullptr){
        pre->next=cur;
        cur=pre;
        pre=work;
        work=work->next;
    }
    pre->next=cur;
    head->next=pre;
}
```

### 

```c++
阿斯弗
```

### 

```c++
阿斯弗
```

### 

```c++
阿斯弗
```

### 

```c++
阿斯弗
```

### 

```c++
阿斯弗
```

### 

```c++
阿斯弗
```



